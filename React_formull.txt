Conditionally returning JSX 
-----------------------------------------
if (isPacked) {
  return <li className="item">{name} ✔</li>;
}
return <li className="item">{name}</li>;

Conditional (ternary) operator (? :) 
-----------------------------------------
return (
  <li className="item">
    {isPacked ? name + ' ✔' : name}
  </li>
);

Logical AND operator (&&) 
-----------------------------------------
return (
  <li className="item">
    {name} {isPacked && '✔'}
  </li>
);

switch case operator for multiple conditional renderings
-----------------------------------------
function Notification({ text, status }) {
  switch (status) {
    case 'info':
      return <Info text={text} />;
    case 'warning':
      return <Warning text={text} />;
    case 'error':
      return <Error text={text} />;
    default:
      return null;
  }
}

NESTED CONDITIONAL RENDERING IN REACT
-----------------------------------------
function List({ list }) {
  const isNotAvailable = !list;
  const isEmpty = !list.length;

  return (
    <div>
      {isNotAvailable
        ? <p>Sorry, the list is not there.</p>
        : (isEmpty
          ? <p>Sorry, the list is empty.</p>
          : <div>{list.map(item => <Item item={item} />)}</div>
        )
      }
    </div>
  
CONDITIONAL RENDERING WITH HOC
-----------------------------------------
// Higher-Order Component
function withLoadingIndicator(Component) {
  return function EnhancedComponent({ isLoading, ...props }) {
    if (!isLoading) {
      return <Component {...props} />;
    }

    return (
      <div>
        <p>Loading</p>
      </div>
    );
  };
}

const ListWithLoadingIndicator = withLoadingIndicator(List);

function App({ list, isLoading }) {
  return (
    <div>
      <h1>Hello Conditional Rendering</h1>

      <ListWithLoadingIndicator isLoading={isLoading} list={list} />
    </div>
  )

CONDITIONAL RENDERING IN REACT: IF
-----------------------------------------
function List({ list }) {
  if (!list) {
    return null;
  }

  return (
    <ul>
      {list.map(item => (
        <Item key={item.id} item={item} />
      ))}
    </ul>
  );
}

CONDITIONAL RENDERING IN REACT: IF ELSE
-----------------------------------------
function List({ list }) {
  if (!list) {
    return null;
  }

  if (!list.length) {
    return <p>Sorry, the list is empty.</p>;
  } else {
    return (
      <div>
        {list.map(item => (
          <Item item={item} />
        ))}
      </div>
    );
  }
}
    
mount, unmount, and updated mount component ( life cycle method)
-----------------------------------------
function ChatRoom() {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect(); // mount component
    return () => {
      connection.disconnect(); // unmount component
    };
  }, []); // when dependency declared there are updated mount component
  // ...
}    


Pass props to the child component 
-----------------------------------------
export default function Profile() {
  return (
    <Avatar
      person={{ name: 'Lin Lanying', imageId: '1bX5QH6' }}
      size={100}
    />
  );
}

Manipulating the DOM with Refs
-----------------------------------------
import { useRef } from 'react';

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleClick}>
        Focus the input
      </button>
    </>
  );
}


Accessing another component’s DOM nodes (you have to use forwardRef for it, IF you can access directly got a error cannot access)
-----------------------------------------
import { forwardRef, useRef } from 'react';

const MyInput = forwardRef((props, ref) => {
  return <input {...props} ref={ref} />;
});

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <MyInput ref={inputRef} />
      <button onClick={handleClick}>
        Focus the input
      </button>
    </>
  );
}


video play and pause using ref method
-----------------------------------------
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  });

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  return (
    <>
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
      />
    </>
  );
}


Reusing Logic with Custom Hooks
-----------------------------------------
// custome hook defined it in app folder and create new folder customHook like component folder
// useCounter.js (it's a custom hook) 
    import { useState } from 'react';

    const useCounter = () => {
      const [count, setCount] = useState(0);

      const increment = () => {
        setCount(prevCount => prevCount + 1);
      };

      return { count, increment };
    };

    export default useCounter;


// ExampleComponent.js
    import React from 'react';
    import useCounter from './useCounter';

    const ExampleComponent = () => {
      const { count, increment } = useCounter();

      return (
        <div>
          <h1>Count: {count}</h1>
          <button onClick={increment}>Increment</button>
        </div>
      );
    };

    export default ExampleComponent;

Higher Order Component demo (HOC)
-----------------------------------------
import React, { useState } from "react";
function HigherOrderUpdatedComponent(OriginalComponent) { // its a HOC component
  function UpdatedComponent() {
    const [money, setMoney] = useState(10);
    const handleIncrease = () => {
      setMoney(money * 2);
    };
    return <OriginalComponent handleIncrease={handleIncrease} money={money} />;
  }
  return UpdatedComponent;
}
export default HigherOrderUpdatedComponent;


function Person1({ money, handleIncrease }) {
  return (
    <>
      <h2>Jimmy is offering me $10 </h2>
      <button onclick={handleIncrease}>Increase Money</button>
    </>
  );
}
export default HigherOrderUpdatedComponent(Person1);


function Person2({ money, handleIncrease }) {
  return (
    <>
      <h2>John is offering me $10 </h2>
      <button onclick={handleIncrease}>Increase Money</button>
    </>
  );
}
export default HigherOrderUpdatedComponent(Person2);


useCallback Hook
-----------------------------------------
// The React useCallback Hook returns a memoized callback function. The useCallback Hook only runs when one of its dependencies updated.
// Formulla : useCallback(fn, dependencies) 

Callback.js
-----------
    import { useCallback, useState } from "react";
    import Todos from "../components/Todos";

    const Callbackhook = () => {
      const [count, setCount] = useState(0);
      const [todos, setTodos] = useState([]);

      const increment = () => {
        setCount(count + 1);
      };

      const addTodo = useCallback(() => {
        setTodos((prev) => [...prev, `new Entry`]);
      }, [todos]);

      // const addTodo = () => {
      //   setTodos((prev) => [...prev, `new Entry`]);
      // };

      // subscribe to thapa technical

      return (
        <>
          <Todos todos={todos} addTodo={addTodo} />
          <hr />
          <div>
            Count: {count}
            <button onClick={increment}>+</button>
          </div>
        </>
      );
    };

    export default Callbackhook;

todos.js 
--------
    import { memo } from "react";

    const Todos = ({ todos, addTodo }) => {
      console.log("child render");
      return (
        <>
          <h2>My Todos</h2>
          {todos.map((todo, index) => {
            return <p key={index}>{todo + index}</p>;
          })}

          <button onClick={addTodo}>Add Todo</button>
        </>
      );
    };

    export default memo(Todos);


useReducer hook
-----------------------------------------
// useReducer is very similar to useState, when we have more that one value we can use useReducer hook

import { useReducer } from "react";

const initialState = 0;

function reducer(state, action) {
  if (action.type === "INCREMENT") {
    return state + 1;
  }
  if (action.type === "DECREMENT") {
    return state - 1;
  }
  return state;
}

export default function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState); // useReducer hook take two arguments first reducer function and second is initialState and dispatch method trigger that action

  return (
    <>
      <button
        onClick={() => {
          dispatch({ type: "INCREMENT" });
        }}
      >
        Increment
      </button>

      <p>{state}</p>

      <button
        onClick={() => {
          dispatch({ type: "DECREMENT" });
        }}
      >
        Decrement
      </button>
    </>
  );
}

useContext hook
-----------------------------------------
// React Context is a way to manage state globally. It can be used together with the useState Hook to share state between deeply nested components more easily
import { createContext, useContext, useState } from "react";

const ThemeContext = createContext(); // here create context

export default function MyApp() {
  const [theme, setTheme] = useState("light");
  return (
    <ThemeContext.Provider value={theme}> // here provide value
      <Form />
      <label>
        <input
          type="checkbox"
          checked={theme === "dark"}
          onChange={(e) => {
            setTheme(e.target.checked ? "dark" : "light");
          }}
        />
        Use dark mode
      </label>
    </ThemeContext.Provider>
  );
}

function Form({ children }) {
  return (
    <Panel title="Welcome">
      <Button>Sign up</Button>
      <Button>Log in</Button>
    </Panel>
  );
}

function Panel({ title, children }) {
  const theme = useContext(ThemeContext); // here get value
  const className = "panel-" + theme;
  return (
    <section className={className}>
      <h1>{title}</h1>
      {children}
    </section>
  );
}

function Button({ children }) {
  const theme = useContext(ThemeContext);
  const className = "button-" + theme;
  return <button className={className}>{children}</button>;
}


useMemo hook
-----------------------------------------
// The React useMemo Hook returns a memoized value. The useMemo Hook only runs when one of its dependencies is updated.
import React, { useState, useMemo } from "react";

const Memo = () => {
  const [myNum, setMyNum] = useState(0);
  const [show, setShow] = useState(false);

  const getValue = () => {
    return setMyNum(myNum + 1);
  };

  const countNumber = (num) => {
    console.log("🚀 ~ file: Memo.jsx ~ line 12 ~ countNumber ~ num", num);
    for (let i = 0; i <= 1000000000; i++) {}
    return num;
  };

  // subscribe to thapa technical

  const checkData = useMemo(() => {
    return countNumber(myNum);
  }, [myNum]);

  return (
    <>
      <button onClick={getValue} style={{ backgroundColor: "red" }}>
        Counter
      </button>
      <p> My new number : {checkData} </p>
      <button onClick={() => setShow(!show)}>
        {show ? "You clicked me" : "Click me plz"}
      </button>
    </>
  );
};

export default Memo;

-----------------------------------------


-----------------------------------------


-----------------------------------------


-----------------------------------------


-----------------------------------------


-----------------------------------------


-----------------------------------------


-----------------------------------------
