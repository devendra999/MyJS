higher order component
mount, unmount, and updated mount component ( life cycle method)
forwardRef
Reusing Logic with Custom Hooks
useCallback Hook
useReducer hook
useContext hook
memo
useMemo hook
useTransition
useLayoutEffect


HOC Main demo
-------------------------------
    1. App.js
        import {BooksHOC, SongsHOC} from './hoc'

        function App() {
            return (
                <>
                    <BooksHOC name='books' theme='dark'></BooksHOC>
                    <SongsHOC name='songs'></SongsHOC>
                </>
            );
        }

        export default App;

    2. hoc.js
        const DB = {
            books: [
                {title: "Harry Potter", author:'Rowling'},
                {title: "Outlier", author:'Gladwell'}
            ],
            songs: [
                {title: "Du Hast", album:'Sehnsucht'},
                {title: "Desert Rose", album:'Brand new day'}
            ]
        };
        
        
        const Books  =  ({books})=>{
            return (
                <div>
                    <h1>Books</h1>
                <ul>
                    {books.map(book=><li>Book: {book.title} / Author: {book.author}</li>)}
                </ul>
                </div>
            
            )
        }
        
        const Songs  =  ({songs})=>{
            return (
                <div>
                <h1>Songs</h1>
                <ul>
                    {songs.map(song=><li>Book: {song.title} / Album: {song.album}</li>)}
                </ul>
        </div>
            )
        }
        
        // this is higher order component
        const withHOC = (Component, getData)=>{
            return (props)=>(
            <div className={props.theme}>
            <Component {...getData(props.name)} ></Component>
            </div>)
        }
        
        const BooksHOC = withHOC(Books,(name)=>({[name]:DB[name]}))
        const SongsHOC = withHOC(Songs,(name)=>({[name]:DB[name]}))
        
        
        export {Books, Songs, BooksHOC, SongsHOC}


Difference between function and class componet
---------------------------------------------------
functional
- A functional component is just a plain JavaScript pure function that accepts props as an argument and returns a React element(JSX).	

    - There is no render method used in functional components.	

    - Constructors are not used.	

class
    - A class component requires you to extend from React. Component and create a render function that returns a React element.

    - It must have the render() method returning JSX (which is syntactically similar to HTML)

    - Constructor is used as it needs to store state. 


Contexnt box and border box
---------------------------------------------------
By default, an element's width and height only include the content, excluding padding and border.

.box {
  width: 200px;
  height: 100px;
  padding: 20px;
  border: 10px solid black;
  box-sizing: content-box; /* Default */
}

ðŸ‘‰ Total width = 200px (content) + 40px (padding) + 20px (border) = 260px
ðŸ‘‰ Total height = 100px (content) + 40px (padding) + 20px (border) = 160px

Issue: This can break layouts if the total size exceeds expectations.

border-box
.box {
  width: 200px;
  height: 100px;
  padding: 20px;
  border: 10px solid black;
  box-sizing: border-box;
}
ðŸ‘‰ Total width = 200px (includes padding & border)
ðŸ‘‰ Total height = 100px (includes padding & border)



What is the data-* Attribute in React?
-----------------------------------------
The data-* attribute in HTML allows you to store custom metadata in elements. In React, it's useful for passing information without needing state or props.

  why use
  âœ… Lightweight: No need for extra state or props.
  âœ… Easier Event Handling: Pass dynamic values in event listeners.
  âœ… Useful for Event Delegation: Helps identify clicked elements.





Conditionally returning JSX 
-----------------------------------------
if (isPacked) {
  return <li className="item">{name} âœ”</li>;
}
return <li className="item">{name}</li>;

Conditional (ternary) operator (? :) 
-----------------------------------------
return (
  <li className="item">
    {isPacked ? name + ' âœ”' : name}
  </li>
);

Logical AND operator (&&) 
-----------------------------------------
return (
  <li className="item">
    {name} {isPacked && 'âœ”'}
  </li>
);

switch case operator for multiple conditional renderings
-----------------------------------------
function Notification({ text, status }) {
  switch (status) {
    case 'info':
      return <Info text={text} />;
    case 'warning':
      return <Warning text={text} />;
    case 'error':
      return <Error text={text} />;
    default:
      return null;
  }
}

NESTED CONDITIONAL RENDERING IN REACT
-----------------------------------------
function List({ list }) {
  const isNotAvailable = !list;
  const isEmpty = !list.length;

  return (
    <div>
      {isNotAvailable
        ? <p>Sorry, the list is not there.</p>
        : (isEmpty
          ? <p>Sorry, the list is empty.</p>
          : <div>{list.map(item => <Item item={item} />)}</div>
        )
      }
    </div>
  
CONDITIONAL RENDERING WITH HOC
-----------------------------------------
// higher-order component is a function that takes a component as an argument and returns a new component that wraps the original component.


1. Creating the Counter Component

  import React, { useState } from 'react';

  const Counter = () => {
    const [count, setCount] = useState(0);

    return (
      <div style={{ padding: '20px', textAlign: 'center' }}>
        <p>Count: {count}</p>
        <button onClick={() => setCount(count + 1)}>Increment</button>
        <button onClick={() => setCount(count - 1)}>Decrement</button>
        <button onClick={() => setCount(0)}>Reset</button>
      </div>
    );
  };

  export default Counter;


2. Creating the withBackgroundColor HOC

  import React from 'react';

  const withBackgroundColor = (WrappedComponent, backgroundColor) => {
    return (props) => {
      const style = {
        backgroundColor: backgroundColor,
        padding: '20px',
        borderRadius: '8px',
        margin: '10px',
      };

      return (
        <div style={style}>
          <WrappedComponent {...props} />
        </div>
      );
    };
  };

  export default withBackgroundColor;


3. Wrapping the Counter Component with Different Colors

import React from 'react';
import Counter from './Counter';
import withBackgroundColor from './withBackgroundColor';

// Create Counter components with different background colors
const RedCounter = withBackgroundColor(Counter, 'red');
const GreenCounter = withBackgroundColor(Counter, 'green');
const BlueCounter = withBackgroundColor(Counter, 'blue');

const App = () => {
  return (
    <div style={{ display: 'flex', justifyContent: 'center', gap: '20px' }}>
      <RedCounter />
      <GreenCounter />
      <BlueCounter />
    </div>
  );
};

export default App;


CONDITIONAL RENDERING IN REACT: IF
-----------------------------------------
function List({ list }) {
  if (!list) {
    return null;
  }

  return (
    <ul>
      {list.map(item => (
        <Item key={item.id} item={item} />
      ))}
    </ul>
  );
}

CONDITIONAL RENDERING IN REACT: IF ELSE
-----------------------------------------
function List({ list }) {
  if (!list) {
    return null;
  }

  if (!list.length) {
    return <p>Sorry, the list is empty.</p>;
  } else {
    return (
      <div>
        {list.map(item => (
          <Item item={item} />
        ))}
      </div>
    );
  }
}
    
mount, unmount, and updated mount component ( life cycle method)
-----------------------------------------
function ChatRoom() {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect(); // mount component or componentDidMount
    return () => {
      connection.disconnect(); // unmount component or componentWillUnmount
    };
  }, []); // when dependency declared there are updated mount component or componentDidUpdate
  // ...
}    


Pass props to the child component 
-----------------------------------------
export default function Profile() {
  return (
    <Avatar
      person={{ name: 'Lin Lanying', imageId: '1bX5QH6' }}
      size={100}
    />
  );
}


Child to parent Data transfer
-----------------------------------------
  // ParentComponent.js
      import React, { useState } from 'react';
      import ChildComponent from './ChildComponent';
      
      function ParentComponent() {
          const [dataFromChild, setDataFromChild] = useState('');
      
          const handleDataFromChild = (data) => {
              setDataFromChild(data);
          };
      
          return (
              <div>
                  <ChildComponent sendDataToParent={handleDataFromChild} />
                  <p>Data from child component: {dataFromChild}</p>
              </div>
          );
      }
      
      export default ParentComponent;

  // ChildComponent.js
      import React from 'react';
      function ChildComponent({ sendDataToParent }) {
          const sendData = () => {
              const data = 'Hello, Parent!';
              sendDataToParent(data); // Call the function passed from the parent with the data
          };
      
          return (
              <div>
                  <button onClick={sendData}>Send Data to Parent</button>
              </div>
          );
      }
      export default ChildComponent;




Manipulating the DOM with Refs
-----------------------------------------
import { useRef } from 'react';

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleClick}>
        Focus the input
      </button>
    </>
  );
}


forwardRef
-----------------------------------------
// Accessing another componentâ€™s DOM nodes (you have to use forwardRef for it, IF you can access directly got a error cannot access)

// forwardRef is a function that allows you to pass a ref from a parent component to a child component. This is useful when you need to access the DOM element of a child component or a child component needs to expose some of its internals to the parent.


    1. Creating a FancyButton Component.
        import React, { forwardRef } from 'react';
          // FancyButton component using forwardRef
          const FancyButton = forwardRef((props, ref) => {
            return (
              <button ref={ref} className="fancy-button">
                {props.children}
              </button>
            );
          });

        export default FancyButton;


    2. Using the FancyButton Component with a Ref
        import React, { useRef } from 'react';
        import FancyButton from './FancyButton';

        const App = () => {
          const buttonRef = useRef(null);

          const handleClick = () => {
            if (buttonRef.current) {
              buttonRef.current.style.backgroundColor = 'yellow'; // Change background color on click
              buttonRef.current.focus(); // Focus the button
            }
          };

          return (
            <div>
              <FancyButton ref={buttonRef}>Click Me!</FancyButton>
              <button onClick={handleClick}>Change FancyButton Style</button>
            </div>
          );
        };

        export default App;




video play and pause using ref method
-----------------------------------------
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  });

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  return (
    <>
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
      />
    </>
  );
}


Reusing Logic with Custom Hooks
-----------------------------------------
// Custom hooks in React are functions that allow you to reuse logic across multiple components. They are a way to extract and share code that deals with stateful logic using React hooks like useState, useEffect, useContext, and others.

// custome hook defined it in app folder and create new folder customHook like component folder
// useCounter.js (it's a custom hook) // custome hook create with start use keyword like: useCounter
    import { useState } from 'react';

    const useCounter = () => {
      const [count, setCount] = useState(0);

      const increment = () => {
        setCount(prevCount => prevCount + 1);
      };

      return { count, increment };
    };

    export default useCounter;


// ExampleComponent.js
    import React from 'react';
    import useCounter from './useCounter';

    const ExampleComponent = () => {
      const { count, increment } = useCounter();

      return (
        <div>
          <h1>Count: {count}</h1>
          <button onClick={increment}>Increment</button>
        </div>
      );
    };

    export default ExampleComponent;




memo
-----------------------------------------
// Memo lets you skip re-rendering a component when its props are unchanged.

import React from "react";
import { memo } from 'react';

const MyComponent = memo((props) => {
  // component logic here
});

export default MyComponent;



useMemo hook
-----------------------------------------
// The React useMemo Hook returns a memoized value. The useMemo Hook only runs when one of its dependencies is updated.

  import React, { useState, useMemo } from 'react';
  
  const MyComponent = () => {
    const [number, setNumber] = useState(0);
    
    // Define a memoized value using useMemo
    const squaredNumber = useMemo(() => {
      console.log("Calculating squared number...");
      return number * number;
    }, [number]); // Recalculate only when 'number' changes
    
    return (
      <div>
        <h2>Number: {number}</h2>
        <button onClick={() => setNumber(prev => prev + 1)}>Increment Number</button>
        <h2>Squared Number: {squaredNumber}</h2>
      </div>
    );
  };
  
  export default MyComponent;



useCallback Hook
-----------------------------------------
// The React useCallback Hook returns a memoized callback function. The useCallback Hook only runs when one of its dependencies updated.
// Formulla : useCallback(fn, dependencies) 

Callback.js
-----------
const Child = React.memo(({ onClick }) => {
  console.log("Child render");
  return <button onClick={onClick}>Click me</button>;
});

const Parent = () => {
  const [count, setCount] = useState(0);

  // Memoizing the function
  const handleClick = useCallback(() => {
    setCount((prevCount) => prevCount + 1);
  }, []); // Empty dependency array ensures the function doesn't get recreated

  return (
    <div>
      <h1>Count: {count}</h1>
      <Child onClick={handleClick} />
    </div>
  );
};



Difference between useMemo and useCallback hook
-----------------------------------------------
  The useCallback and useMemo Hooks are similar. The main difference is that useMemo returns a memoized value and useCallback returns a memoized function.
    
     // Usage:
    
    useMemo: Use when you have expensive calculations that you don't want to repeat unless necessary.
    useCallback: Prevent Unnecessary Re-renders of Child Components
    
    // return 
    useMemo: Returns the memoized value.
    useCallback: Returns the memoized function.
    
    // When to Use Which:
    
    Use useMemo: When you have an expensive computation (like a large array or complex calculation) that you want to avoid recalculating unless necessary.
    Example: Filtering a large list, calculating derived data.
    
    Use useCallback: When you want to avoid unnecessary re-creations of a function thatâ€™s passed as a prop to a child component or used as a dependency in useEffect.
    Example: Passing a click handler to a child component that relies on stable references to avoid re-renders.



useReducer hook
-----------------------------------------
// useReducer is very similar to useState, when we have more that one value we can use useReducer hook. It allows for custom state logic.

import { useReducer } from "react";

const initialState = 0;

function reducer(state, action) {
  if (action.type === "INCREMENT") {
    return state + 1;
  }
  if (action.type === "DECREMENT") {
    return state - 1;
  }
  return state;
}

export default function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState); // useReducer hook take two arguments first reducer function and second is initialState and dispatch method trigger that action

  return (
    <>
      <button
        onClick={() => {
          dispatch({ type: "INCREMENT" });
        }}
      >
        Increment
      </button>

      <p>{state}</p>

      <button
        onClick={() => {
          dispatch({ type: "DECREMENT" });
        }}
      >
        Decrement
      </button>
    </>
  );
}



useContext hook
-----------------------------------------
// React Context is a way to manage state globally. It can be used together with the useState Hook to share state between deeply nested components more easily

  1. create context folder in root directory create productContext.js file

      productContext.js(File)
      -----------------------
        import { createContext, useContext, useEffect, useReducer } from "react";
        import reducer from "../reducer/ProductReducer";
  
        export const ProductContext = createContext();
  
        export const useProductContext = () => {
          return useContext(ProductContext);
        };
  
        const initialState = {
            products: [],
        };
        export const ProductContextProvider = ({ children }) => { // create custom hook here
        const [state, dispatch] = useReducer(reducer, initialState);
  
          return (
            <ProductContext.Provider value={{ ...state, }}> // also passed function like : getSingleProduct
              {children}
            </ProductContext.Provider>
          );
        };
  
  
  2. wrapped this for all js in index.js or layoutout.js or app.js file
  
      index.js(File)
      -----------------------
      import { ProductContextProvider } from "./context/ProductContext";
  
      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(
        <React.StrictMode>
          <ProductContextProvider>
                <App />
          </ProductContextProvider>
        </React.StrictMode>
      );
  
  3. use directory in page
  
      page.js(File)
      -----------------------
      import { useProductContext } from "../context/ProductContext";
      
      const FeaturedProduct = () => {
        const { featuredProducts } = useProductContext();
        return (
          <>
            <div className="featured-section space bg-gray">
              <div className="container">
                <h2 className="main-title">Our Feature Services</h2>
                <div className="row">
                  {featuredProducts && featuredProducts.length > 0
                    ? featuredProducts.map((prod, index) => {
                        return <Product key={index} product={prod} />;
                      })
                    : "No Featured products found"}
                </div>
              </div>
            </div>
          </>
        );
      };
  
      export default FeaturedProduct;



useTransition
-----------------------------------------
// useTransition is a React Hook that lets you update the state without blocking the UI.
// Formulla: const [isPending, startTransition] = useTransition()

import React, { useState, useTransition } from "react";

function UseTranstion() {
  const [items, setItems] = useState(["Item 1", "Item 2", "Item 3"]);
  const [isPending, startTransition] = useTransition({
    timeoutMs: 500
  });

  const handleItemClick = (index) => {
    startTransition(() => {
      setItems((prevItems) => {
        const updatedItems = [...prevItems];
        updatedItems.splice(index, 1);
        return updatedItems;
      });
    });
  };

  return (
    <ul>
      {items.map((item, index) => (
        <li key={index} onClick={() => handleItemClick(index)}>
          {item}
        </li>
      ))}
      {isPending && <div>Loading....</div>}
    </ul>
  );
}

export default UseTranstion;


useLayoutEffect
-----------------------------------------
// useLayoutEffect, runs synchronously after a render but before the screen is updated.
// useEffect runs asynchronously and after a render is painted to the screen.

import React, { useState, useLayoutEffect, useEffect } from "react";

const LayoutEffect = () => {
  const [num, setNum] = useState(0);

  useLayoutEffect(() => {
    if (num === 0) setNum(5 + Math.random() * 50);
  }, [num]);
  console.log("ðŸš€ ~ file: LayoutEffect.jsx ~ line 9 ~ LayoutEffect ~ num", num);
  
  return (
    <>
      <h2>{num}</h2>
      <button onClick={() => setNum(0)}>check</button>
    </>
  );
};

export default LayoutEffect;


Where use useLayoutEffect and useEffect
-----------------------------------------
useLayoutEffect
  - Measuring DOM elements or modifie them (e.g., width, height)
  - Synchronous animations

useEffect
  - API calls, logging	


// =======================================================================================================================================
// other js
// =======================================================================================================================================

how to make react app from scratch
---------------------------------

1. Set Up the Project
	- Install Node.js and NPM
	- npx create-react-app

2. Develop the App (Build Components)
	- Build Components: Start building your React components in the /src directory. Each component should have a clear responsibility and be reusable.
	- Add Styles: Use plain CSS or tailwind css or scss
	- State Management: As your app grows, you may need to manage the state using useState, useReducer, or even state management libraries like Redux.

4. Optimize for Production
	- Build the App: Once youâ€™re done with the development, itâ€™s time to create a production-ready build. - 
		- cmd : npm run build
		This will create a build/ folder that contains an optimized version of your app (minified JS, optimized assets, etc.).

5. Choose a Deployment Method
	Option 2: Deploy on Vercel (Easy) or Netlify or heroku
	Create an Account: Sign up at Vercel.
	Connect to GitHub: Push your code to a GitHub repository.
	Deploy: Click "New Project" and connect to your GitHub repo.
	Configure: Vercel automatically detects that itâ€™s a React app, but ensure the build command is npm run build and the output folder is build/.
	Deploy: Click "Deploy" and Vercel will give you a live URL.

6. Set Up Continuous Deployment (Optional but Recommended)
	Once your app is pushed to a GitHub repository, you can set up Continuous Deployment (CD) with services like GitHub Actions (for CI/CD) or Netlify/Vercel.
	Every time you push new code to your GitHub repo, the platform will rebuild and redeploy the app automatically.


what is micro frontend
---------------------------------
Working with Micro Frontends in a React application allows you to break a large application into smaller, independent modules, each owned by a different team. These modules can be developed, deployed, and updated separately, improving scalability and maintainability.


event delegation
---------------------------------
Event delegation is a powerful pattern that takes advantage of event bubbling. It simplifies code, improves performance, and ensures event listeners work for dynamically added elements. ðŸš€

    When to Use Event Delegation
    âœ… When elements are dynamically added or removed.
    âœ… When handling many child elements (e.g., lists, tables, grids).
    âœ… When optimizing performance and memory usage.


Browser api
---------------------------------
A Browser API (Application Programming Interface) is a set of built-in functions and objects provided by web browsers that allow developers to interact with various features of the browser and the web page. 

    1. DOM (Document Object Model) API
    2. BOM (Browser Object Model) API
    3. Fetch API (Networking)
    4. Storage APIs
    5. Notification API



Tools and techniques for debugging React applications?
---------------------------------
    ðŸ”¹ 1ï¸âƒ£ React Developer Tools (React DevTools)
    ðŸ”¹ ðŸ”Ÿ Error Handling with try-catch
    ðŸ”¹ 2ï¸âƒ£ Console Logging (console.log)
    ðŸ”¹ 4ï¸âƒ£ React Strict Mode
    ðŸ”¹ 5ï¸âƒ£ Using the Debugger Statement
    ðŸ”¹ 6ï¸âƒ£ Browser Developer Tools (Chrome DevTools)
    ðŸ”¹ 7ï¸âƒ£ Redux DevTools (For Redux Apps)



code-splitting
---------------------------------
Dividing the app into smaller bundles	
Breaks JavaScript files into chunks	
Improves bundle size & performance	


Webpack
---------------------------------
Webpack is a module bundler that helps React applications bundle, optimize, and serve JavaScript, CSS, images, and other assets efficiently.

    ðŸ”¹ Why Webpack in React?
    âœ… Bundling: Combines multiple JavaScript files into one.
    âœ… Code Splitting: Loads only the required code, reducing the initial load time.
    âœ… Asset Optimization: Minifies JS, CSS, and images for faster performance.
    âœ… Tree Shaking: Removes unused code to make the app smaller.



lazzy loading
---------------------------------
Lazy Loading is a technique where resources (components, images, or data) are loaded only when they are needed, instead of loading everything at once.
Works for components, images, and data
Reduces unnecessary loading

import React, { Suspense } from "react";

// Lazy load the component
const LazyComponent = React.lazy(() => import("./LazyComponent"));

function App() {
  return (
    <div>
      <h1>React Lazy Loading Demo</h1>
      
      {/* Suspense provides a fallback while the component loads */}
      <Suspense fallback={<h2>Loading Component...</h2>}>
        <LazyComponent />
      </Suspense>
    </div>
  );
}

export default App;


LazyComponent.js
    function LazyComponent() {
    return <h2>This is a lazily loaded component! ðŸŽ‰</h2>;
    }

    export default LazyComponent;




javascript prototype and inheritance
---------------------------------
In JavaScript, every object has an internal property called [[Prototype]], which refers to another object. objects can inherit properties and methods from other objects using a prototype chain. Prototype inheritance allows objects to share methods without copying them.

// Constructor function
function Person(name, age) {
    this.name = name;
    this.age = age;
}

// Adding a method to the prototype
Person.prototype.greet = function() {
    console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);
};

// Creating instances
const person1 = new Person("Alice", 25);
const person2 = new Person("Bob", 30);

// Calling the inherited method
person1.greet(); // Hello, my name is Alice and I am 25 years old.
person2.greet(); // Hello, my name is Bob and I am 30 years old.



agile technology
---------------------------------
In an Agile environment, various technologies and tools are used to support development processes.

1. 1ï¸âƒ£ Version Control & Collaboration
	- Git (GitHub, GitLab, Bitbucket) â€“ For source code management
	- JIRA / Trello / Azure DevOps â€“ For Agile project tracking (Scrum/Kanban)

2. 2ï¸âƒ£ CI/CD (Continuous Integration & Deployment)
	- GitHub Actions, Jenkins, CircleCI, GitLab CI/CD â€“ Automate testing & deployment
	
3. 3ï¸âƒ£ Code Quality & Testing
	- ESLint / Prettier / Husky â€“ Code linting & formatting
	- Jest, React Testing Library, Cypress â€“ Unit & UI testing
	- SonarQube â€“ Code quality checks

4. 4ï¸âƒ£ Agile Development in React
	- Storybook â€“ Component-driven development

5. 5ï¸âƒ£ Cloud & Hosting
	- Vercel / Netlify / AWS Amplify â€“ For fast React app deployment
	- Firebase / Supabase â€“ Serverless backend



closure
------------------------------------------------------------------------------------------------------------------
A closure is the combination of a function. 

closure in action that is inner function can have access to the outer function variables/parameters as well as all the global variables.

    closure example
    ---------------
    const outerFunc = (a) => {
        let b = 10;
        const innerFunc = () => {
            let sum = a + b;
        }
        return innerFunc;  
    }    

    outerFunc(5)

    lexical scoping example
    ------------------------
    const outerFunc = (a) => {
        let b = 10;
        const innerFunc = () => {
            let sum = a + b;
        }
        innerFunc();  
    }    

    outerFunc(5)


local storage and session storage
-------------------------------------------
local Storage : 
Data stored in localStorage persists even after the browser is closed or the tab is refreshed.
Shared across all tabs and windows of the same origin	

session Storage :
Data stored in sessionStorage is only available for the duration of the page session.
Specific to a single tab or window
The data is cleared when the browser tab is closed or the window is refreshed.




difference between rest and spread operator
-------------------------------------------
rest : Used in function parameters to collect multiple arguments into a single array(also known as "rest parameters").
Used in destructuring to collect the remaining properties into an object or array.

    // in function
    function sum(...numbers) { // rest
        return numbers.reduce((acc, num) => acc + num, 0);
    }

    // Object destructuring
    const person = { name: 'Alice', age: 25, country: 'USA' };
    const { name, ...rest } = person;
    console.log(name); // Alice
    console.log(rest); // { age: 25, country: 'USA' }

    // Array destructuring
    const numbers = [1, 2, 3, 4];
    const [first, ...restNumbers] = numbers;
    console.log(first); // 1
    console.log(restNumbers); // [2, 3, 4]


spread: Used in function calls to spread the elements of an array into individual arguments.
Used in object or array literals to copy or combine objects / arrays.

    // in function
    function greet(firstName, lastName) {
        console.log(`Hello, ${firstName} ${lastName}!`);
    }

    const names = ['Alice', 'Smith'];
    greet(...names); // Output: Hello, Alice Smith!


    // Object spread
    const person = { name: 'Alice', age: 25 };
    const updatedPerson = { ...person, country: 'USA' };
    console.log(updatedPerson); // { name: 'Alice', age: 25, country: 'USA' }

    // Array spread
    const numbers = [1, 2, 3];
    const newNumbers = [...numbers, 4, 5];
    console.log(newNumbers); // [1, 2, 3, 4, 5]




let const var - block scope
--------------------------------------------------------
    global scope â€“ so you can access it everywhere (inside and outside functions).
    var 
        global and local scope
        reassign, redeclare

        function print() {
            var number = 50
            var square = number * number
            console.log(square)
        }
        console.log(number) // ReferenceError: number is not defined, because of variable diclare in local scope

        function print() {
            var square1 = number * number
            console.log(square1) // NaN

            var number = 50

            var square2 = number * number
            console.log(square2) // 2500
        }


    let 
        global, block and local scope
        reassign, can not redeclare
        You can find blocks in if, loop, switch
        
        let number = 50
        function print() {
            let square = number * number

            if (number < 60) {
                var largerNumber = 80
                let anotherLargerNumber = 100

                console.log(square)  // 2500
            }

            console.log(largerNumber) //80
            console.log(anotherLargerNumber) // ReferenceError: anotherLargerNumber is not defined, because of block scope
        }
        console.log(largerNumber) // ReferenceError: largerNumber is not defined

        let number = 50
        let number = 100 // SyntaxError: Identifier 'number' has already been declared

        console.log(number) // ReferenceError: Cannot access 'number' before initialization
        let number = 50


    const 
        global, block and local scope
        can not reassign, can not redclare, but object can modified 

        const number = 50
        number = 100 // TypeError: Assignment to constant variable







Currying 
----------------------------------------------------------
Currying is a functional programming, that transforms the function of multiple arguments into several functions of a single argument in sequence. 

    normal function
    ---------------
        function getSum(a) {
            return function (b) {
                return function (c) {
                    console.log(a + b + c)
                }
            }
        }
        getSum(a)(b)(c)
   
    Fat arrow function
    ---------------
        const getSum = (a) => (b) => (c) => a+b+c;
        getSum(a)(b)(c)




Pure functions
------------------------------------------------------------------------------------------------------------------
Pure functions are functions that accept an input and return a value without modifying and data outside its predictible and don't modify and variable

    var x = 10;
    function add() {
        return x+1;
    }
    add(10)



The Async/Await
------------------------------------------------------------------------------------------------------------------
Async : To create an asynchronous function, you need to add the async keyword before your function name.
Await : The await keyword basically makes JavaScript wait until the Promise object is resolved or rejected.

    How to Handle Errors in Async/Await
    -----------------------------------
        async function runProcess() {
            try {
                const response = await fetch('https://jsonplaceholder.typicode.com/todos/1');
                const json = await response.json();
                console.log(json);
            } catch (error) {
                console.log(error);
            }
        }

        With arrow function
        -------------------
        const runProcess = async () => {
            try {
                const response = await fetch('https://jsonplaceholder.typicode.com/todos/1');
                const json = await response.json();
                console.log(json);
            } catch (error) {
                console.log(error);
            }
        };




    Using Fatch
    -----------
    fetch('https://jsonplaceholder.typicode.com/todos/1')
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(error => console.log(error));




Promises
------------------------------------------------------------------------------------------------------------------
// A Promise represents an operation that hasnâ€™t completed yet but is expected to in the future. It can be in one of three states:
        1. Pending: The initial state, neither fulfilled nor rejected.
        2. Fulfilled: The operation completed successfully.
        3. Rejected: The operation failed

    // Create a new Promise
    let fetchData = new Promise((resolve, reject) => {
        // Simulate a delay with setTimeout
        setTimeout(() => {
            const success = true; // Change to false to see the rejection scenario
            
            if (success) {
                resolve("Data fetched successfully!"); // Operation was successful
            } else {
                reject("Failed to fetch data."); // Operation failed
            }
        }, 2000); // 2 seconds delay
    });
    
    // Handle the Promise
    fetchData
        .then((message) => {
            console.log(message); // This will run if the Promise is resolved
        })
        .catch((error) => {
            console.error(error); // This will run if the Promise is rejected
        });




* difference between Context API and the useContext hook
--------------------------------------------------------------------------
The main difference between Context API and the useContext hook is that Context API can be used in both class and functional components, while the useContext hook is restricted to functional components: 




* difference between forin and for of loop
--------------------------------------------------------------------------
forin - Iterates over keys or property names	
        Suitable for iterating object properties
        Iterates over array indices (not values)	
        Objects, arrays, and other enumerable types	

    demo
        const person = { name: 'Alice', age: 25 };
        for (let key in person) {
            console.log(key);  // 'name' and 'age'
            console.log(person[key]);  // 'Alice' and '25'
        }
    

forof - Iterates over values of iterable objects
Not suitable for iterating object properties
Iterates over array values
Arrays, strings, maps, sets, and other iterables




JavaScript: call(), bind(), and apply()
-------------------------------
These are methods in JavaScript that allow us to control the this context of a function. They are useful when borrowing methods, setting explicit contexts, and function customization.

1ï¸âƒ£ call()
call() immediately executes the function with a different this value.
Invokes the function immediately.
The first argument is the this value.
Additional arguments are passed individually.

Example
const person = {
  fullName: function (city, country) {
    console.log(`${this.firstName} ${this.lastName} from ${city}, ${country}`);
  }
};

const person1 = { firstName: "John", lastName: "Doe" };

person.fullName.call(person1, "New York", "USA");
// Output: John Doe from New York, USA



2ï¸âƒ£ apply()
Similar to call(), but arguments are passed as an array.

Example
const person2 = { firstName: "Alice", lastName: "Smith" };

person.fullName.apply(person2, ["London", "UK"]);
// Output: Alice Smith from London, UK


3ï¸âƒ£ bind()
Does not execute immediately.
Returns a new function with this permanently bound.

Example
const person3 = { firstName: "Mike", lastName: "Brown" };

const boundFunction = person.fullName.bind(person3, "Paris", "France");
boundFunction();
// Output: Mike Brown from Paris, France





* Differences Between map and forEach Statement in JavaScript
--------------------------------------------------------------------------
The main difference between map and forEach is that map returns a new array with the results of the function applied to each element, 
while forEach does not return anything. using forEach can modify the original array if the callback function modifies its elements.8 Sept 2023

// Using forEach
const arr1 = [1, 2, 3];
arr1.forEach(num => console.log(num * 2)); 
// Output: 2, 4, 6 (prints each value but returns undefined)

// Using map
const arr2 = [1, 2, 3];
const newArr = arr2.map(num => num * 2);
console.log(newArr); 
// Output: [2, 4, 6] (returns a new array with transformed values)





this
-----------------------------
the this keyword refers to an object.
Alone, this refers to the global object.
In a function, this refers to the global object.
In a function, in strict mode, this is undefined.

    console.log(this); // In browsers: window

    "use strict";
    let x = this; // this refer to window object


    function showThis() {
      console.log(this);
    }
    
    showThis(); // window (without strict mode) | undefined (with strict)

    const person = {
        firstName: "John",
        lastName: "Doe",
        id: 5566,
        fullName : function() {
          return this.firstName + " " + this.lastName; // this refer to person object
        }
      };


      5ï¸âƒ£ this in an Arrow Function
        ðŸ”¹ Arrow functions do not have their own this.
        ðŸ”¹ Instead, they inherit this from their lexical scope (where they are defined).

        const person = {
          name: "Alice",
          greet: function() {
            const arrowFunc = () => {
              console.log(this.name);
            };
            arrowFunc();
          }
        };
        
        person.greet(); // "Alice"


        6ï¸âƒ£ this in an Event Listener
        document.querySelector("button").addEventListener("click", function() {
          console.log(this); // The clicked button element
        });
        



difference null and undefined
-----------------------------
null
      - Intentional absence of value	
      - object (typeof null)	

undefined
      - Value is not assigned
      - undefined (typeof undefined)


difference shallow copy and deep copy
-----------------------------
A shallow copy creates a new object, but it still references nested objects from the original.
A deep copy creates a completely independent copy, including all nested objects. JSON.parse(JSON.stringify(array))



Debouncing and Throttling
-----------------------------
Debouncing : Debouncing is a technique that delays the execution of a function until the user stops performing a certain action for a specified amount of time. 
    For example, if you have a search bar that fetches suggestions from the backend as the user types, you can debounce the function that makes the API call, so that it only runs after the user stops typing for a few seconds. This way, you can avoid making too many API calls that might overload your server or return irrelevant results.

    example
    -------
        // Simulated API function
        function fetchDataFromApi() {
            console.log("API call made");
            // Replace this with your actual API call
        }

        // Debounce function
        function debounce(func, delay) {
            let timeoutId;
            
            return function() {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(func, delay);
            };
        }

        // Create a debounced version of the API call function
        const debouncedFetchData = debounce(fetchDataFromApi, 1000); // Debounce for 1 second (1000 milliseconds)

        // Simulated event triggering API call
        function handleUserInput() {
            console.log("User input detected");
            debouncedFetchData();
        }

        // Simulated user input event (e.g., button click)
        handleUserInput(); // This will trigger API call after 1 second
        handleUserInput(); // This will cancel the previous timer and start a new one, API call will be made after 1 second




Throttling : Throttling is a technique that limits the execution of a function to once in every specified time interval.
    For example, if you have a resize event handler that adjusts the layout of your page, you can throttle the function that updates the layout, so that it only runs once every 100ms.


    example
    -------

        // Function to be throttled
        function handleResize() {
          console.log("Window resized");
          // Your resizing logic goes here
        }
        
        // Throttle function
        function throttle(func, limit) {
          let lastExecutionTime = 0;
        
          return function() {
            const now = Date.now();
            if (now - lastExecutionTime >= limit) {
              func();
              lastExecutionTime = now;
            }
          };
        }
        
        // Throttle the resize event handler
        const throttledResizeHandler = throttle(handleResize, 1000); // Throttle to at most one execution per second
        
        // Attach the throttled event handler to the window resize event
        window.addEventListener("resize", throttledResizeHandler);
        


split
-----------------------------------
The split() method is used to split a string into an array of substrings based on a specified delimiter. it does not change original string or array
	let text = "Hello World JavaScript";
	let words = text.split(" ");
	console.log(words); 
	// ["Hello", "World", "JavaScript"]


splice and slice
-----------------------------------
splice() â€“ Add/Remove Elements (Modifies Original Array)
	let arr = [1, 2, 3, 4, 5];
	// Remove elements (start index = 1, delete 2 elements)
	let removed = arr.splice(1, 2);
	console.log(arr); // [1, 4, 5]  (Original array is modified)
	console.log(removed); // [2, 3]  (Removed elements)


slice() â€“ Extracts a Portion of an Array (Returns New Array)
	let arr = [1, 2, 3, 4, 5];
	// Extract elements from index 1 to 3 (not including index 3)
	let newArr = arr.slice(1, 3);
	console.log(newArr); // [2, 3] (New array)
	console.log(arr); // [1, 2, 3, 4, 5] (Original remains unchanged)



what is hooks
-----------------------------------
	Hooks are special functions in React that let you use state and lifecycle features inside functional components, without needing class components. They 	were introduced in React 16.8 to simplify state management and side effects.



Middlewere
----------------------------------
Middleware is a request handler that allows you to intercept and manipulate requests and responses before they reach route handlers.
Middleware is a crucial concept in many programming frameworks and libraries, particularly in web development. It sits between the incoming request and the outgoing response in the request-response cycle and allows you to perform various tasks such as request processing, authentication, logging, error handling, and more.







setTimeout, setInterval and clearTimeout
-------------------------------------------------------------
setTimeout: setTimeout allows you to run a function after a certain amount of time has passed.
            
            setTimeout(function, milliseconds);

            // With parameter or argument
            setTimeout(function (param1, param2) {
                // Code to be executed after the delay
            }, delay);



setInterval : setInterval is a function in JavaScript that is used to repeatedly execute a given function at a specified interval. 
                
                setInterval(myTimer, 1000);

                function myTimer() {
                    const date = new Date();
                    document.getElementById("demo").innerHTML = date.toLocaleTimeString();
                }


clearTimeout : clearTimeout allows developers to clear and reset the timer created by the setTimeout() method.
               
                const myTimeout = setTimeout(myGreeting, 3000);

                function myGreeting() {
                 document.getElementById("demo").innerHTML = "Happy Birthday!"
                }

                function myStopFunction() {
                 clearTimeout(myTimeout);
                }




Function declaration
--------------------------------------------------------
hoistedFunction(); // This works even though hoistedFunction is called before its declaration

function hoistedFunction() {
  console.log("This is a hoisted function");
}



Function expression
--------------------------------------------------------
notHoistedFunction(); // This will throw an error because notHoistedFunction is not defined at this point

const notHoistedFunction = function() {
  console.log("This is not a hoisted function");
};



var a = null;
console.log(a == null) // true
console.log(a == undefined) // true


const
The const declaration declares block-scoped local variables. 
The value of a constant can't be changed through reassignment using the assignment operator,
but if a constant is an object, its properties can be added, updated, or removed.



The recursive call
--------------------------------------------------------
    The recursive call is what handles the function calling itself again. In the doSomething function, the recursive call is the line below.
    expamle
        function doSomething(n) {
            if(n === 0) {
            console.log("TASK COMPLETED!")
            return
            }
            console.log("I'm doing something.")
            doSomething(n - 1)
        }
        doSomething(3)


What is an event loop in JavaScript ?
---------------------------------------
  The event loop is a core concept in JavaScript that enables non-blocking, asynchronous behavior in a single-threaded environment. Hereâ€™s a breakdown of how it works:

  How the Event Loop Works
      1. Single Threaded: JavaScript executes in a single-threaded environment, meaning only one operation can run at a time. However, it can handle multiple operations by offloading tasks to the browser or Node.js APIs.

      2. Call Stack: When functions are called, they are added to the call stack. The JavaScript engine executes functions from the top of the stack and removes them once they complete.

      .3. Web APIs: Asynchronous functions (like setTimeout, HTTP requests, etc.) are sent to Web APIs (in the browser) or Node.js APIs. These functions run in the background, and when they complete, they send their callback functions to the callback queue.

      4. Callback Queue: When the call stack is empty (all synchronous tasks are complete), the event loop checks the callback queue. If there are any callback functions waiting in the queue, it pushes them onto the call stack for execution.

      5. Event Loop: The event loop continuously checks if the call stack is empty and moves tasks from the callback queue to the call stack. This allows JavaScript to manage asynchronous operations effectively without blocking the main execution thread.


Event
-------------------------------
    Events are "things" that happen to HTML elements. When JavaScript is used in HTML pages, JavaScript can react on these events


Lazy Loading (next/dynamic)
----------------------------------------
    Lazy loading in Next.js helps improve the initial loading performance of an application by decreasing the amount of JavaScript needed to render a route.
    
    
    'use client'
     
    import { useState } from 'react'
    import dynamic from 'next/dynamic'
     
    // Client Components:
    const ComponentA = dynamic(() => import('../components/A'), { loading: () => <h2>Loading...</h2>, ssr: false })
     
    export default function ClientComponentExample() {
      const [showMore, setShowMore] = useState(false)
     
      return (
        <>
            <h1>Hello world</h1>
            {/* Load on demand, only when/if the condition is met */}
            <button onClick={() => setShowMore(!showMore)}>Load component a</button>
    
            {showMore && <ComponentB />}
    
        </>
      )
    }


image
-------------------------------
    Benifit
    - Size Optimization: Automatically serve correctly sized images for each device, using modern image formats like WebP and AVIF.
    - Visual Stability: Prevent layout shift automatically when images are loading.
    - Faster Page Loads: Images are only loaded when they enter the viewport using native browser lazy loading, with optional blur-up placeholders.
    - Asset Flexibility: On-demand image resizing, even for images stored on remote servers 
    

virtual dom how work ?
--------------------------------------------------------------------------------
    lightweight copy of the real DOM in memory
    
    When a React app is first rendered, React creates a Virtual DOM based on the component tree.
    React then compares the Virtual DOM with the real DOM to determine what changes need to be made.
    The result of this comparison is a set of changes (or "diffs"), which are then applied to the real DOM.

What is React js
--------------------------------------------------------------------------------
    React is a JavaScript library for building user interfaces. React is used to build single - page applications. React allows us to create reusable UI components.

How does React Work?
--------------------------------------------------------------------------------
    React creates a VIRTUAL DOM in memory.
    Instead of manipulating the browser's DOM directly, React creates a virtual DOM in memory, where it does all the necessary manipulating, before making the changes in the browser DOM.

ES6
--------------------------------------------------------------------------------
    Classes
    Arrow Functions
    Variables(let, const, var)
    Array Methods like .map()
    Destructuring
    Modules
    Ternary Operator
    Spread Operator

what is JSX?
--------------------------------------------------------------------------------
    JSX stands for JavaScript XML.JSX allows us to write HTML in React. JSX makes it easier to write and add HTML in React. expression is {}

React Components
--------------------------------------------------------------------------------
    Components are independent and reusable bits of code.They serve the same purpose as JavaScript functions, but work in isolation and return HTML.
    Components come in two types, Class components and Function components, in this tutorial we will concentrate on Function components.

Props
--------------------------------------------------------------------------------
    Props are arguments passed into React components. Props are passed to components via HTML attributes. props stands for properties.
    Props are also how you pass data from one component to another, as parameters.

    To do this without Context, we will need to pass the state as "props" through each nested component. This is called "prop drilling".

React Events
--------------------------------------------------------------------------------
    Just like HTML DOM events, React can perform actions based on user events. React has the same events as HTML: click, change, mouseover etc.
    React event handlers are written inside curly braces: onClick={shoot} instead of onClick="shoot()".

keys or React List
--------------------------------------------------------------------------------
    Keys allow React to keep track of elements. the key should be a unique ID assigned to each item. As a last resort, you can use the array index as a key.
    A key is a special attribute you should include when mapping over arrays to render data. Key prop helps React identify which items have changed, are added, or are removed.
    


framework vs library
--------------------------------------------------------------------------------
framework - flow already defined, in framework there are multiple library used
library - flow defined by us, in library we cannot use framework



What is the difference between Element and Component?
--------------------------------------------------------------------------------
    An Element is a plain object describing what you want to appear on the screen in terms of the DOM nodes or other components. Elements can contain other Elements in their props. Creating a React element is cheap. Once an element is created, it cannot be mutated.

    Whereas a component can be declared in several different ways. It can be a class with a render() method or it can be defined as a function. In either case, it takes props as an input, and returns a JSX tree as the output:



difference between package.jsand package-lock.js
--------------------------------------------------------------------------------
package
    - Lists dependencies and scripts needed for the project.
    - Specifies semantic versioning (e.g., ^1.2.3 or ~1.2.3).
    - Used to share the project setup with others.

package-lock
    - Locks the exact versions of installed dependencies.
    - Stores exact versions (18.2.0, 1.0.5)
    - Helps in reproducible builds.



difference between dependency and dev-dependency
--------------------------------------------------------------------------------
1ï¸âƒ£ dependencies â€“ Required for the app to run.
                - These packages are needed at runtime (when the app is running).
                - Used in both development and production environments.
                - react, react-router-dom, axios, redux, material ui, tailwind css

2ï¸âƒ£ devDependencies â€“ Required only for development and testing.
                    - Only needed during development (not in production).
                    - Includes tools for testing, linting, and bundling.
                    - eslint, jest, webpack, babel, typescript


how to update package
--------------------------------------------------------------------------------
1. npm install <package-name>@latest
2. npm update react
3. yarn upgrade react
4. npm install -g npm-check-updates (all packages)




Controlled vs Uncontrolled Components in ReactJS
--------------------------------------------------------------------------------
    In React, Controlled components refer to the components where the state and behaviors are controlled by Parent components while Uncontrolled components are the ones having control of their own state and manage the behaviors on themselves.

    Uncontrolled Components are the components that are not controlled by the React state and are handled by the DOM (Document Object Model). So in order to access any value that has been entered we take the help of refs.
    


        
The asynchronous callback
--------------------------------------------------------------------------------
    The asynchronous callback is executed after the execution of the higher-order function.
    Simply saying, the asynchronous callbacks are non-blocking: the higher-order function completes its execution without waiting for the callback. The higher-order function makes sure to execute the callback later on a certain event.

    example
    1. console.log('setTimeout() starts');
        setTimeout(function later() {
            console.log('later() called');
        }, 2000);
        console.log('setTimeout() completed');

        // logs 'setTimeout() starts'
        // logs 'setTimeout() completed'
        // logs 'later() called' (after 2 seconds)



Asynchronous callback function vs asynchronous function
--------------------------------------------------------------------------------
    The special keyword async placed before the function definition creates an asynchornous function:
    setTimeout is Asynchronous callback function





1. What is ReactJS?
    ReactJS is a JavaScript library used to build reusable components for the view layer in MVC architecture. It is highly efficient and uses a virtual DOM to render components. It works on the client side and is written in JSX.

2. What is Next js?
    Next.js is a powerful and flexible React framework that enables developers to build server-rendered and statically generated web applications.



20. What is StrictMode in React ?
  The React StrictMode can be viewed as a helper component that allows developers to code efficiently and brings to their attention any suspicious code which might have been accidentally added to the application. The StrictMode can be applied to any section of the application, not necessarily to the entire application



11. What is axios and how to use it in React?
  Axios, which is a popular library is mainly used to send asynchronous HTTP requests to REST endpoints. This library is very useful to perform CRUD operations.


10. Explain CORS in React?
  In ReactJS, Cross-Origin Resource Sharing (CORS) refers to the method that allows you to make requests to the server deployed at a different domain. As a reference, if the frontend and backend are at two different domains, we need CORS there.


3. What is the difference between useref and createRef in React ?
  useRef
      It is a hook.	
      It uses the same ref throughout.	
      It returns a mutable ref object.	
      It is used in functional components.	

  createRef
      It is a function.
      It creates a new ref every time.
      It returns a read-only ref object.
      It is used in class components.



20. What are synthetic event in React?
      In order to work as a cross-browser application, React has created a wrapper same as the native browser in order to avoid creating multiple implementations for multiple methods for multiple browsers, creating common names for all events across browsers. Another benefit is that it increases the performance of the application as React reuses the event object. 
  
  

12. What is a react developer tool?
      React Developer Tools is a Chrome DevTools extension for the React JavaScript library. A very useful tool, if you are working on React.js applications. This extension adds React debugging tools to the Chrome Developer Tools. It helps you to inspect and edit the React component tree that builds the page, and for each component, one can check the props, the state, hooks, etc.


11. What is React Fragments?
      when we are trying to render more than one root element we have to put the entire content inside the â€˜divâ€™ tag which is not loved by many developers. So since React 16.2 version, Fragments were introduced, and we use them instead of the extraneous â€˜divâ€™ tag. The following syntax is used to create fragment in react.



8. What are hooks in React?
      In React, Hooks are functions that allow you to "hook into" React's state and lifecycle features from functional components. They were introduced in React 16.8 to make it easier to manage state, side effects, context, and other React features without needing to write class components. Hooks enable you to write more modular and reusable code in functional components.
  
  Before hooks, state and lifecycle methods could only be used in class components. Hooks eliminate this limitation, making functional components just as powerful and flexible as class components.


20. Explain one way data binding in React?
  ReactJS uses one-way data binding which can be Component to View or View to Component. It is also known as one-way data flow


8. How do browsers read JSX?
  In general, browsers are not capable of reading JSX and only have the capacity to read pure JavaScript. The web browsers read JSX with the help of a transpiler.
   Transpilers are used to convert JSX into JavaScript. The transpiler used is called Babel


Rendering
--------------------------------------------
CSR: Client side rendering 
    In CSR, the web page's HTML is built and rendered in the browser (on the client's device). The browser downloads a basic HTML file, then loads JavaScript to fetch data and render the page dynamically.

    Rendering happens on the client side, using JavaScript.

SSR: Server side rendering - generate on each request
    In SSR, the server creates the complete HTML for a page and sends it to the browser. This means the page is fully rendered before it reaches the client, allowing it to be displayed faster.

    Rendering happens on the server, then sent to the client on each request.

SSG: Static site Generated - generate on build time
    SSG generates HTML at build time. The HTML files are pre-built and stored on a server, which means they load extremely fast when requested by a user.

    html, css and js generate on build time
    HTML is pre-built at build time and served statically




javascript
--------------------------------------------------
1. What is Javascript and its purpose
 2. Explain what kind of application we can built using Javascript 
3. What are variables and explain the rules to create a variable
 4. What are Data types
 5. Explain Primitive and Non Primitive Data type
 6. What is function in Javascript 
7. Explain the Difference between callback and higherorder function in JS?
 8. What is difference between let ,cons and var
 9. What is spread operator
 10. What is Rest Parameter 
11. What is promise in Javascript 
12. Explain different States of Promise in Javascript 
13. How to create a Promise
 14. What is difference between promise and callback in Javascript
 15. What is Callback
 16. What is higher order function in Javascript 
17. Explain different types of function in Javascript 
18. What is arrow function in Javascript 
19. Why we use call, apply bind method in 
20. Javascript
 21. How many way to create object in Javascript
 22. What are the array method , string method 
23. What is difference between java and javascript 
24. What is Null and undefined in javascript 
25. What is setTimeOut and setInterval in Javascript
 26. What is sessionStorage, localStorage 
27. What are is map, filter , reducer in javascript 
28. What is closure in Javascript 
29. What is housing in Javascript 
30. What is the difference between array and object 
31. What is the difference between number type and BigInt type
 32. What is the difference between call() and apply()
 33. What is DOM and DOM Manipulation 
34. How to create element dynamically using Javascript 
35. Explain Closures in Javascript 
36. Explain different Scopes in Javascript 
37. What is import and export 
38. What is Destructing in the Javascript 
39. Difference between Normal Functin and Arrow Function 
40. Explain the difference between map() and filter() 
41. Explain difference between map() and forEach() 
42. What are events in Javascript
 43. What is null and undefined in Javascript 
44. Explain the difference between == and ===
