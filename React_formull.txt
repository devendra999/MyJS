higher order component
mount, unmount, and updated mount component ( life cycle method)
forwardRef
Reusing Logic with Custom Hooks
useCallback Hook
useReducer hook
useContext hook
memo
useMemo hook
useDebugValue
useDeferredValue
useTransition
useLayoutEffect
useImperativeHandle
useInsertionEffect
useSyncExternalStore



Difference between function and class componet
---------------------------------------------------
functional
    - A functional component is just a plain JavaScript pure function that accepts props as an argument and returns a React element(JSX).	

    - There is no render method used in functional components.	

    - Constructors are not used.	

class
    - A class component requires you to extend from React. Component and create a render function that returns a React element.

    - It must have the render() method returning JSX (which is syntactically similar to HTML)

    - Constructor is used as it needs to store state. 






Conditionally returning JSX 
-----------------------------------------
if (isPacked) {
  return <li className="item">{name} âœ”</li>;
}
return <li className="item">{name}</li>;

Conditional (ternary) operator (? :) 
-----------------------------------------
return (
  <li className="item">
    {isPacked ? name + ' âœ”' : name}
  </li>
);

Logical AND operator (&&) 
-----------------------------------------
return (
  <li className="item">
    {name} {isPacked && 'âœ”'}
  </li>
);

switch case operator for multiple conditional renderings
-----------------------------------------
function Notification({ text, status }) {
  switch (status) {
    case 'info':
      return <Info text={text} />;
    case 'warning':
      return <Warning text={text} />;
    case 'error':
      return <Error text={text} />;
    default:
      return null;
  }
}

NESTED CONDITIONAL RENDERING IN REACT
-----------------------------------------
function List({ list }) {
  const isNotAvailable = !list;
  const isEmpty = !list.length;

  return (
    <div>
      {isNotAvailable
        ? <p>Sorry, the list is not there.</p>
        : (isEmpty
          ? <p>Sorry, the list is empty.</p>
          : <div>{list.map(item => <Item item={item} />)}</div>
        )
      }
    </div>
  
CONDITIONAL RENDERING WITH HOC
-----------------------------------------
// higher-order component is a function that takes a component as an argument and returns a new component that wraps the original component.


1. Creating the Counter Component

  import React, { useState } from 'react';

  const Counter = () => {
    const [count, setCount] = useState(0);

    return (
      <div style={{ padding: '20px', textAlign: 'center' }}>
        <p>Count: {count}</p>
        <button onClick={() => setCount(count + 1)}>Increment</button>
        <button onClick={() => setCount(count - 1)}>Decrement</button>
        <button onClick={() => setCount(0)}>Reset</button>
      </div>
    );
  };

  export default Counter;


2. Creating the withBackgroundColor HOC

  import React from 'react';

  const withBackgroundColor = (WrappedComponent, backgroundColor) => {
    return (props) => {
      const style = {
        backgroundColor: backgroundColor,
        padding: '20px',
        borderRadius: '8px',
        margin: '10px',
      };

      return (
        <div style={style}>
          <WrappedComponent {...props} />
        </div>
      );
    };
  };

  export default withBackgroundColor;


3. Wrapping the Counter Component with Different Colors

import React from 'react';
import Counter from './Counter';
import withBackgroundColor from './withBackgroundColor';

// Create Counter components with different background colors
const RedCounter = withBackgroundColor(Counter, 'red');
const GreenCounter = withBackgroundColor(Counter, 'green');
const BlueCounter = withBackgroundColor(Counter, 'blue');

const App = () => {
  return (
    <div style={{ display: 'flex', justifyContent: 'center', gap: '20px' }}>
      <RedCounter />
      <GreenCounter />
      <BlueCounter />
    </div>
  );
};

export default App;


CONDITIONAL RENDERING IN REACT: IF
-----------------------------------------
function List({ list }) {
  if (!list) {
    return null;
  }

  return (
    <ul>
      {list.map(item => (
        <Item key={item.id} item={item} />
      ))}
    </ul>
  );
}

CONDITIONAL RENDERING IN REACT: IF ELSE
-----------------------------------------
function List({ list }) {
  if (!list) {
    return null;
  }

  if (!list.length) {
    return <p>Sorry, the list is empty.</p>;
  } else {
    return (
      <div>
        {list.map(item => (
          <Item item={item} />
        ))}
      </div>
    );
  }
}
    
mount, unmount, and updated mount component ( life cycle method)
-----------------------------------------
function ChatRoom() {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect(); // mount component or componentDidMount
    return () => {
      connection.disconnect(); // unmount component or componentWillUnmount
    };
  }, []); // when dependency declared there are updated mount component or componentDidUpdate
  // ...
}    


Pass props to the child component 
-----------------------------------------
export default function Profile() {
  return (
    <Avatar
      person={{ name: 'Lin Lanying', imageId: '1bX5QH6' }}
      size={100}
    />
  );
}


Child to parent Data transfer
-----------------------------------------
  // ParentComponent.js
      import React, { useState } from 'react';
      import ChildComponent from './ChildComponent';
      
      function ParentComponent() {
          const [dataFromChild, setDataFromChild] = useState('');
      
          const handleDataFromChild = (data) => {
              setDataFromChild(data);
          };
      
          return (
              <div>
                  <ChildComponent sendDataToParent={handleDataFromChild} />
                  <p>Data from child component: {dataFromChild}</p>
              </div>
          );
      }
      
      export default ParentComponent;

  // ChildComponent.js
      import React from 'react';
      function ChildComponent({ sendDataToParent }) {
          const sendData = () => {
              const data = 'Hello, Parent!';
              sendDataToParent(data); // Call the function passed from the parent with the data
          };
      
          return (
              <div>
                  <button onClick={sendData}>Send Data to Parent</button>
              </div>
          );
      }
      export default ChildComponent;




Manipulating the DOM with Refs
-----------------------------------------
import { useRef } from 'react';

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleClick}>
        Focus the input
      </button>
    </>
  );
}


forwardRef
-----------------------------------------
// Accessing another componentâ€™s DOM nodes (you have to use forwardRef for it, IF you can access directly got a error cannot access)

// forwardRef is a function that allows you to pass a ref from a parent component to a child component. This is useful when you need to access the DOM element of a child component or a child component needs to expose some of its internals to the parent.


    1. Creating a FancyButton Component.
        import React, { forwardRef } from 'react';
          // FancyButton component using forwardRef
          const FancyButton = forwardRef((props, ref) => {
            return (
              <button ref={ref} className="fancy-button">
                {props.children}
              </button>
            );
          });

        export default FancyButton;


    2. Using the FancyButton Component with a Ref
        import React, { useRef } from 'react';
        import FancyButton from './FancyButton';

        const App = () => {
          const buttonRef = useRef(null);

          const handleClick = () => {
            if (buttonRef.current) {
              buttonRef.current.style.backgroundColor = 'yellow'; // Change background color on click
              buttonRef.current.focus(); // Focus the button
            }
          };

          return (
            <div>
              <FancyButton ref={buttonRef}>Click Me!</FancyButton>
              <button onClick={handleClick}>Change FancyButton Style</button>
            </div>
          );
        };

        export default App;




video play and pause using ref method
-----------------------------------------
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  });

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  return (
    <>
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
      />
    </>
  );
}


Reusing Logic with Custom Hooks
-----------------------------------------
// Custom hooks in React are functions that allow you to reuse logic across multiple components. They are a way to extract and share code that deals with stateful logic using React hooks like useState, useEffect, useContext, and others.

// custome hook defined it in app folder and create new folder customHook like component folder
// useCounter.js (it's a custom hook) // custome hook create with start use keyword like: useCounter
    import { useState } from 'react';

    const useCounter = () => {
      const [count, setCount] = useState(0);

      const increment = () => {
        setCount(prevCount => prevCount + 1);
      };

      return { count, increment };
    };

    export default useCounter;


// ExampleComponent.js
    import React from 'react';
    import useCounter from './useCounter';

    const ExampleComponent = () => {
      const { count, increment } = useCounter();

      return (
        <div>
          <h1>Count: {count}</h1>
          <button onClick={increment}>Increment</button>
        </div>
      );
    };

    export default ExampleComponent;




memo
-----------------------------------------
// Memo lets you skip re-rendering a component when its props are unchanged.

import React from "react";
import { memo } from 'react';

const MyComponent = memo((props) => {
  // component logic here
});

export default MyComponent;



useMemo hook
-----------------------------------------
// The React useMemo Hook returns a memoized value. The useMemo Hook only runs when one of its dependencies is updated.

  import React, { useState, useMemo } from 'react';
  
  const MyComponent = () => {
    const [number, setNumber] = useState(0);
    
    // Define a memoized value using useMemo
    const squaredNumber = useMemo(() => {
      console.log("Calculating squared number...");
      return number * number;
    }, [number]); // Recalculate only when 'number' changes
    
    return (
      <div>
        <h2>Number: {number}</h2>
        <button onClick={() => setNumber(prev => prev + 1)}>Increment Number</button>
        <h2>Squared Number: {squaredNumber}</h2>
      </div>
    );
  };
  
  export default MyComponent;



useCallback Hook
-----------------------------------------
// The React useCallback Hook returns a memoized callback function. The useCallback Hook only runs when one of its dependencies updated.
// Formulla : useCallback(fn, dependencies) 

Callback.js
-----------
    import { useCallback, useState } from "react";
    import Todos from "../components/Todos";

    const Callbackhook = () => {
      const [count, setCount] = useState(0);
      const [todos, setTodos] = useState([]);

      const increment = () => {
        setCount(count + 1);
      };

      const addTodo = useCallback(() => {
        setTodos((prev) => [...prev, `new Entry`]);
      }, [todos]);

      // const addTodo = () => {
      //   setTodos((prev) => [...prev, `new Entry`]);
      // };

      // subscribe to thapa technical

      return (
        <>
          <Todos todos={todos} addTodo={addTodo} />
          <hr />
          <div>
            Count: {count}
            <button onClick={increment}>+</button>
          </div>
        </>
      );
    };

    export default Callbackhook;

todos.js 
--------
    import { memo } from "react";

    const Todos = ({ todos, addTodo }) => {
      console.log("child render");
      return (
        <>
          <h2>My Todos</h2>
          {todos.map((todo, index) => {
            return <p key={index}>{todo + index}</p>;
          })}

          <button onClick={addTodo}>Add Todo</button>
        </>
      );
    };

    export default memo(Todos);



Difference between useMemo and useCallback hook
-----------------------------------------------
  The useCallback and useMemo Hooks are similar. The main difference is that useMemo returns a memoized value and useCallback returns a memoized function.
    
     // Usage:
    
    useMemo: Use when you have expensive calculations that you don't want to repeat unless necessary.
    useCallback: Use when you need to prevent a function from being recreated on every render, especially when passing it as a prop to child components.
    Return Value:
    
    // return 
    useMemo: Returns the memoized value.
    useCallback: Returns the memoized function.
    
    // When to Use Which:
    
    Use useMemo: When you have an expensive computation (like a large array or complex calculation) that you want to avoid recalculating unless necessary.
    Example: Filtering a large list, calculating derived data.
    
    Use useCallback: When you want to avoid unnecessary re-creations of a function thatâ€™s passed as a prop to a child component or used as a dependency in useEffect.
    Example: Passing a click handler to a child component that relies on stable references to avoid re-renders.



useReducer hook
-----------------------------------------
// useReducer is very similar to useState, when we have more that one value we can use useReducer hook. It allows for custom state logic.

import { useReducer } from "react";

const initialState = 0;

function reducer(state, action) {
  if (action.type === "INCREMENT") {
    return state + 1;
  }
  if (action.type === "DECREMENT") {
    return state - 1;
  }
  return state;
}

export default function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState); // useReducer hook take two arguments first reducer function and second is initialState and dispatch method trigger that action

  return (
    <>
      <button
        onClick={() => {
          dispatch({ type: "INCREMENT" });
        }}
      >
        Increment
      </button>

      <p>{state}</p>

      <button
        onClick={() => {
          dispatch({ type: "DECREMENT" });
        }}
      >
        Decrement
      </button>
    </>
  );
}



useContext hook
-----------------------------------------
// React Context is a way to manage state globally. It can be used together with the useState Hook to share state between deeply nested components more easily

  1. create context folder in root directory create productContext.js file

      productContext.js(File)
      -----------------------
        import { createContext, useContext, useEffect, useReducer } from "react";
        import reducer from "../reducer/ProductReducer";
  
        export const ProductContext = createContext();
  
        export const useProductContext = () => {
          return useContext(ProductContext);
        };
  
        const initialState = {
            products: [],
        };
        export const ProductContextProvider = ({ children }) => { // create custom hook here
        const [state, dispatch] = useReducer(reducer, initialState);
  
          return (
            <ProductContext.Provider value={{ ...state, }}> // also passed function like : getSingleProduct
              {children}
            </ProductContext.Provider>
          );
        };
  
  
  2. wrapped this for all js in index.js or layoutout.js or app.js file
  
      index.js(File)
      -----------------------
      import { ProductContextProvider } from "./context/ProductContext";
  
      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(
        <React.StrictMode>
          <ProductContextProvider>
                <App />
          </ProductContextProvider>
        </React.StrictMode>
      );
  
  3. use directory in page
  
      page.js(File)
      -----------------------
      import { useProductContext } from "../context/ProductContext";
      
      const FeaturedProduct = () => {
        const { featuredProducts } = useProductContext();
        return (
          <>
            <div className="featured-section space bg-gray">
              <div className="container">
                <h2 className="main-title">Our Feature Services</h2>
                <div className="row">
                  {featuredProducts && featuredProducts.length > 0
                    ? featuredProducts.map((prod, index) => {
                        return <Product key={index} product={prod} />;
                      })
                    : "No Featured products found"}
                </div>
              </div>
            </div>
          </>
        );
      };
  
      export default FeaturedProduct;




useDebugValue
-----------------------------------------
// useDebugValue is a React Hook that lets you add a label to a custom Hook in React DevTools.

import { useDebugValue } from "react";

function useOnlineStatus() {
  useDebugValue(isOnline ? "Online" : "Offline");
}


useDeferredValue
-----------------------------------------
// React 18 comes with a number of concurrent features that you can just start using in your existing codebase as there is no concurrent mode anymore. One such feature is the new useDeferedValue hook so lets take a look.
// useDeferredValue is a React Hook that lets you defer updating a part of the UI.
// jab variable ki value bar bar change ho rahi ho, to ui print hone me time lagta he, us solution ke liye deffered value use hota he, deffered value bar bar update nahi hota he jab last me variable update hota he tab vo last me ui update karta he, jisse performance badti he

App.tsx
-------
    import React, { useDeferredValue, useState } from "react";
    import { Products } from "./List";

    function App() {
      const [value, setValue] = useState("");
      const handleChange: React.ChangeEventHandler<HTMLInputElement> = (e) => {
        setValue(e.target.value);
      };

      const deferredValue = useDeferredValue(value);
      const isStale = deferredValue !== value;

      return (
        <div>
          <input
            style={{ color: isStale ? "dimgray" : "black" }}
            value={value}
            onChange={handleChange}
          />
          <Products searchTerm={deferredValue} />
        </div>
      );
    }

    export default App;

Products.tsx
------------
    import { useMemo } from "react";

    export function Products({ searchTerm }: { searchTerm: string }) {
      const items = useMemo(() => {
        return [...Array(10000)].map(
          () =>
            (searchTerm ? searchTerm + " " : "") + Math.floor(Math.random() * 10000)
        );
      }, [searchTerm]);

      return <List items={items} />;
    }


List.tsx
--------
    /**
     * This component is intentionally designed to be slow
     * - bad keys
     * - inline styles
     */
    function List({ items }: { items: string[] }) {
      return (
        <div>
          {items.map((product, i) => (
            <div
              key={i + product}
              style={{
                margin: "1rem 0",
                backgroundColor: "lightskyblue",
                borderRadius: "4px",
                boxShadow: "0 1px 4px rgba(0, 0, 0, 0.25)",
                padding: "10px",
              }}
            >
              {product}
            </div>
          ))}
        </div>
      );
    }



useTransition
-----------------------------------------
// useTransition is a React Hook that lets you update the state without blocking the UI.
// Formulla: const [isPending, startTransition] = useTransition()

import React, { useState, useTransition } from "react";

function UseTranstion() {
  const [items, setItems] = useState(["Item 1", "Item 2", "Item 3"]);
  const [isPending, startTransition] = useTransition({
    timeoutMs: 500
  });

  const handleItemClick = (index) => {
    startTransition(() => {
      setItems((prevItems) => {
        const updatedItems = [...prevItems];
        updatedItems.splice(index, 1);
        return updatedItems;
      });
    });
  };

  return (
    <ul>
      {items.map((item, index) => (
        <li key={index} onClick={() => handleItemClick(index)}>
          {item}
        </li>
      ))}
      {isPending && <div>Loading....</div>}
    </ul>
  );
}

export default UseTranstion;


useLayoutEffect
-----------------------------------------
// useLayoutEffect, runs synchronously after a render but before the screen is updated.
// useEffect runs asynchronously and after a render is painted to the screen.

import React, { useState, useLayoutEffect, useEffect } from "react";

const LayoutEffect = () => {
  const [num, setNum] = useState(0);

  useLayoutEffect(() => {
    if (num === 0) setNum(5 + Math.random() * 50);
  }, [num]);
  console.log("ðŸš€ ~ file: LayoutEffect.jsx ~ line 9 ~ LayoutEffect ~ num", num);

  return (
    <>
      <h2>{num}</h2>
      <button onClick={() => setNum(0)}>check</button>
    </>
  );
};

export default LayoutEffect;



useImperativeHandle
-----------------------------------------
// parent component can Access the child component functions, variables using useImperativeHandle.
// formulla : useImperativeHandle(ref, createHandle, dependencies?)

Parent.js
--------
        import React, {forwordRef} from 'react';
        import Child from './Child';

        function Parent (props, ref) {
            const ref = useRef();
            return <div>
                <Child ref={ref} />
                <div>Parent Component</div>
                <button onClick={ref.current.sayHi()}>click</button>
            </div>
        }
        export default Parent;



Child.js
--------
        import React, {useImperativeHandle, forwordRef} from 'react';

        function Child (props, ref) {
            useImperativeHandle(ref, () => ({ 
                sayHi,
            }));

            const sayHi = () => {
                console.log("Hi, Everyone");
            }
            return <div>Child Component</div>
        }
        export default forwordRef(Child);



useInsertionEffect
-----------------------------------------
// useInsertionEffect allows inserting elements into the DOM before any layout effects fire.
// Formulla : useInsertionEffect(setup, dependencies?)

import {  useEffect, useInsertionEffect, useLayoutEffect, useState } from "react";

const UseInsertionEffectHook = () => {
    const [theme,setTheme] = useState('dark')
    
    useInsertionEffect(() => {
        const styleRule = getStyleRule(theme);

        document.head.appendChild(styleRule);

        return () => document.head.removeChild(styleRule)
    },[theme])

    return <button onClick={() => setTheme(theme === 'dark' ? 'white' : 'dark')}>Change theme</button>
}

const getStyleRule = theme =>{
    const tag = document.createElement('style')
    tag.innerHTML = `
        html,button {
            color : ${theme === 'dark' ? 'white' : 'black'};
            background-color : ${theme === 'dark' ? 'black' : 'white'};
            border : 1px solid ${theme === 'dark' ? 'white' : 'black'};
        }

    `

    return tag
}

export default UseInsertionEffectHook



useSyncExternalStore
-----------------------------------------
// useSyncExternalStore is a React Hook that lets you subscribe to an external store.
// Fromulla : const snapshot = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)

import React, {useSyncExternalStore} from 'react';

export default function App ()  {

    const width = useSyncExternalStore((listner) => {
        window.addEventListener('resize', listner)
        return window.removeEventListener('resize', listner)
    }, () => window.innerWidth);
    
    return <div>Size : {width}</div>
}



// =======================================================================================================================================
// other js
// =======================================================================================================================================



closure
------------------------------------------------------------------------------------------------------------------
A closure is the combination of a function. 

closure in action that is inner function can have access to the outer function variables/parameters as well as all the global variables.

    closure example
    ---------------
    const outerFunc = (a) => {
        let b = 10;
        const innerFunc = () => {
            let sum = a + b;
        }
        return innerFunc;  
    }    

    outerFunc(5)

    lexical scoping example
    ------------------------
    const outerFunc = (a) => {
        let b = 10;
        const innerFunc = () => {
            let sum = a + b;
        }
        innerFunc();  
    }    

    outerFunc(5)






let const var - block scope
--------------------------------------------------------
    global scope â€“ so you can access it everywhere (inside and outside functions).
    var 
        global and local scope
        reassign, redeclare

        function print() {
            var number = 50
            var square = number * number
            console.log(square)
        }
        console.log(number) // ReferenceError: number is not defined, because of variable diclare in local scope

        function print() {
            var square1 = number * number
            console.log(square1) // NaN

            var number = 50

            var square2 = number * number
            console.log(square2) // 2500
        }


    let 
        global, block and local scope
        reassign, can not redeclare
        You can find blocks in if, loop, switch
        
        let number = 50
        function print() {
            let square = number * number

            if (number < 60) {
                var largerNumber = 80
                let anotherLargerNumber = 100

                console.log(square)  // 2500
            }

            console.log(largerNumber) //80
            console.log(anotherLargerNumber) // ReferenceError: anotherLargerNumber is not defined, because of block scope
        }
        console.log(largerNumber) // ReferenceError: largerNumber is not defined

        let number = 50
        let number = 100 // SyntaxError: Identifier 'number' has already been declared

        console.log(number) // ReferenceError: Cannot access 'number' before initialization
        let number = 50


    const 
        global, block and local scope
        can not reassign, can not redclare, but object can modified 

        const number = 50
        number = 100 // TypeError: Assignment to constant variable







Currying 
----------------------------------------------------------
Currying is a functional programming, that transforms the function of multiple arguments into several functions of a single argument in sequence. 

    normal function
    ---------------
        function getSum(a) {
            return function (b) {
                return function (c) {
                    console.log(a + b + c)
                }
            }
        }
        getSum(a)(b)(c)
   
    Fat arrow function
    ---------------
        const getSum = (a) => (b) => (c) => a+b+c;
        getSum(a)(b)(c)




Pure functions
------------------------------------------------------------------------------------------------------------------
Pure functions are functions that accept an input and return a value without modifying and data outside its predictible and don't modify and variable

    var x = 10;
    function add() {
        return x+1;
    }
    add(10)



The Async/Await
------------------------------------------------------------------------------------------------------------------
Async : To create an asynchronous function, you need to add the async keyword before your function name.
Await : The await keyword basically makes JavaScript wait until the Promise object is resolved or rejected.

    How to Handle Errors in Async/Await
    -----------------------------------
        async function runProcess() {
            try {
                const response = await fetch('https://jsonplaceholder.typicode.com/todos/1');
                const json = await response.json();
                console.log(json);
            } catch (error) {
                console.log(error);
            }
        }

        With arrow function
        -------------------
        const runProcess = async () => {
            try {
                const response = await fetch('https://jsonplaceholder.typicode.com/todos/1');
                const json = await response.json();
                console.log(json);
            } catch (error) {
                console.log(error);
            }
        };




    Using Fatch
    -----------
    fetch('https://jsonplaceholder.typicode.com/todos/1')
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(error => console.log(error));




Promises
------------------------------------------------------------------------------------------------------------------
// A Promise represents an operation that hasnâ€™t completed yet but is expected to in the future. It can be in one of three states:
        1. Pending: The initial state, neither fulfilled nor rejected.
        2. Fulfilled: The operation completed successfully.
        3. Rejected: The operation failed

    // Create a new Promise
    let fetchData = new Promise((resolve, reject) => {
        // Simulate a delay with setTimeout
        setTimeout(() => {
            const success = true; // Change to false to see the rejection scenario
            
            if (success) {
                resolve("Data fetched successfully!"); // Operation was successful
            } else {
                reject("Failed to fetch data."); // Operation failed
            }
        }, 2000); // 2 seconds delay
    });
    
    // Handle the Promise
    fetchData
        .then((message) => {
            console.log(message); // This will run if the Promise is resolved
        })
        .catch((error) => {
            console.error(error); // This will run if the Promise is rejected
        });




* difference between Context API and the useContext hook
--------------------------------------------------------------------------
The main difference between Context API and the useContext hook is that Context API can be used in both class and functional components, while the useContext hook is restricted to functional components: 




* difference between forin and for of loop
--------------------------------------------------------------------------
forin - Iterates over keys or property names	
        Suitable for iterating object properties
        Iterates over array indices (not values)	
        Objects, arrays, and other enumerable types	

    demo
        const person = { name: 'Alice', age: 25 };
        for (let key in person) {
            console.log(key);  // 'name' and 'age'
            console.log(person[key]);  // 'Alice' and '25'
        }
    

forof - Iterates over values of iterable objects
Not suitable for iterating object properties
Iterates over array values
Arrays, strings, maps, sets, and other iterables



* Differences Between for-in and for-of Statement in JavaScript
--------------------------------------------------------------------------
The main difference between map and forEach is that map returns a new array with the results of the function applied to each element, while forEach does not return anything. Both map and forEach can modify the original array if the callback function modifies its elements.8 Sept 2023

// Using forEach
const arr1 = [1, 2, 3];
arr1.forEach(num => console.log(num * 2)); 
// Output: 2, 4, 6 (prints each value but returns undefined)

// Using map
const arr2 = [1, 2, 3];
const newArr = arr2.map(num => num * 2);
console.log(newArr); 
// Output: [2, 4, 6] (returns a new array with transformed values)





this
-----------------------------
the this keyword refers to an object.
Alone, this refers to the global object.
In a function, this refers to the global object.
In a function, in strict mode, this is undefined.


    "use strict";
    let x = this; // this refer to window object


    "use strict";
    function myFunction() {
        return this; // this is undefined
    }


    const person = {
        firstName: "John",
        lastName: "Doe",
        id: 5566,
        fullName : function() {
          return this.firstName + " " + this.lastName; // this refer to person object
        }
      };




this
-----------------------------
the this keyword refers to an object.
Alone, this refers to the global object.
In a function, this refers to the global object.
In a function, in strict mode, this is undefined.


    "use strict";
    let x = this; // this refer to window object


    "use strict";
    function myFunction() {
        return this; // this is undefined
    }


    const person = {
        firstName: "John",
        lastName: "Doe",
        id: 5566,
        fullName : function() {
          return this.firstName + " " + this.lastName; // this refer to person object
        }
      };




Debouncing and Throttling
-----------------------------
Debouncing : Debouncing is a technique that delays the execution of a function until the user stops performing a certain action for a specified amount of time. 
    For example, if you have a search bar that fetches suggestions from the backend as the user types, you can debounce the function that makes the API call, so that it only runs after the user stops typing for a few seconds. This way, you can avoid making too many API calls that might overload your server or return irrelevant results.

    example
    -------
        // Simulated API function
        function fetchDataFromApi() {
            console.log("API call made");
            // Replace this with your actual API call
        }

        // Debounce function
        function debounce(func, delay) {
            let timeoutId;
            
            return function() {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(func, delay);
            };
        }

        // Create a debounced version of the API call function
        const debouncedFetchData = debounce(fetchDataFromApi, 1000); // Debounce for 1 second (1000 milliseconds)

        // Simulated event triggering API call
        function handleUserInput() {
            console.log("User input detected");
            debouncedFetchData();
        }

        // Simulated user input event (e.g., button click)
        handleUserInput(); // This will trigger API call after 1 second
        handleUserInput(); // This will cancel the previous timer and start a new one, API call will be made after 1 second




Throttling : Throttling is a technique that limits the execution of a function to once in every specified time interval.
    For example, if you have a resize event handler that adjusts the layout of your page, you can throttle the function that updates the layout, so that it only runs once every 100ms.


    example
    -------

        // Function to be throttled
        function handleResize() {
          console.log("Window resized");
          // Your resizing logic goes here
        }
        
        // Throttle function
        function throttle(func, limit) {
          let lastExecutionTime = 0;
        
          return function() {
            const now = Date.now();
            if (now - lastExecutionTime >= limit) {
              func();
              lastExecutionTime = now;
            }
          };
        }
        
        // Throttle the resize event handler
        const throttledResizeHandler = throttle(handleResize, 1000); // Throttle to at most one execution per second
        
        // Attach the throttled event handler to the window resize event
        window.addEventListener("resize", throttledResizeHandler);
        






Middlewere
----------------------------------
Middleware is a request handler that allows you to intercept and manipulate requests and responses before they reach route handlers.
Middleware is a crucial concept in many programming frameworks and libraries, particularly in web development. It sits between the incoming request and the outgoing response in the request-response cycle and allows you to perform various tasks such as request processing, authentication, logging, error handling, and more.







setTimeout, setInterval and clearTimeout
-------------------------------------------------------------
setTimeout: setTimeout allows you to run a function after a certain amount of time has passed.
            
            setTimeout(function, milliseconds);

            // With parameter or argument
            setTimeout(function (param1, param2) {
                // Code to be executed after the delay
            }, delay);



setInterval : setInterval is a function in JavaScript that is used to repeatedly execute a given function at a specified interval. 
                
                setInterval(myTimer, 1000);

                function myTimer() {
                    const date = new Date();
                    document.getElementById("demo").innerHTML = date.toLocaleTimeString();
                }


clearTimeout : clearTimeout allows developers to clear and reset the timer created by the setTimeout() method.
               
                const myTimeout = setTimeout(myGreeting, 3000);

                function myGreeting() {
                 document.getElementById("demo").innerHTML = "Happy Birthday!"
                }

                function myStopFunction() {
                 clearTimeout(myTimeout);
                }




Function declaration
--------------------------------------------------------
hoistedFunction(); // This works even though hoistedFunction is called before its declaration

function hoistedFunction() {
  console.log("This is a hoisted function");
}



Function expression
--------------------------------------------------------
notHoistedFunction(); // This will throw an error because notHoistedFunction is not defined at this point

const notHoistedFunction = function() {
  console.log("This is not a hoisted function");
};



var a = null;
console.log(a == null) // true
console.log(a == undefined) // true


const
The const declaration declares block-scoped local variables. 
The value of a constant can't be changed through reassignment using the assignment operator,
but if a constant is an object, its properties can be added, updated, or removed.



The recursive call
--------------------------------------------------------
    The recursive call is what handles the function calling itself again. In the doSomething function, the recursive call is the line below.
    expamle
        function doSomething(n) {
            if(n === 0) {
            console.log("TASK COMPLETED!")
            return
            }
            console.log("I'm doing something.")
            doSomething(n - 1)
        }
        doSomething(3)


What is an event loop in JavaScript ?
---------------------------------------
  The event loop is a core concept in JavaScript that enables non-blocking, asynchronous behavior in a single-threaded environment. Hereâ€™s a breakdown of how it works:

  How the Event Loop Works
      1. Single Threaded: JavaScript executes in a single-threaded environment, meaning only one operation can run at a time. However, it can handle multiple operations by offloading tasks to the browser or Node.js APIs.

      2. Call Stack: When functions are called, they are added to the call stack. The JavaScript engine executes functions from the top of the stack and removes them once they complete.

      .3. Web APIs: Asynchronous functions (like setTimeout, HTTP requests, etc.) are sent to Web APIs (in the browser) or Node.js APIs. These functions run in the background, and when they complete, they send their callback functions to the callback queue.

      4. Callback Queue: When the call stack is empty (all synchronous tasks are complete), the event loop checks the callback queue. If there are any callback functions waiting in the queue, it pushes them onto the call stack for execution.

      5. Event Loop: The event loop continuously checks if the call stack is empty and moves tasks from the callback queue to the call stack. This allows JavaScript to manage asynchronous operations effectively without blocking the main execution thread.


Event
-------------------------------
    Events are "things" that happen to HTML elements. When JavaScript is used in HTML pages, JavaScript can react on these events


Lazy Loading (next/dynamic)
----------------------------------------
    Lazy loading in Next.js helps improve the initial loading performance of an application by decreasing the amount of JavaScript needed to render a route.
    
    
    'use client'
     
    import { useState } from 'react'
    import dynamic from 'next/dynamic'
     
    // Client Components:
    const ComponentA = dynamic(() => import('../components/A'), { loading: () => <h2>Loading...</h2>, ssr: false })
     
    export default function ClientComponentExample() {
      const [showMore, setShowMore] = useState(false)
     
      return (
        <>
            <h1>Hello world</h1>
            {/* Load on demand, only when/if the condition is met */}
            <button onClick={() => setShowMore(!showMore)}>Load component a</button>
    
            {showMore && <ComponentB />}
    
        </>
      )
    }


image
-------------------------------
    Benifit
    - Size Optimization: Automatically serve correctly sized images for each device, using modern image formats like WebP and AVIF.
    - Visual Stability: Prevent layout shift automatically when images are loading.
    - Faster Page Loads: Images are only loaded when they enter the viewport using native browser lazy loading, with optional blur-up placeholders.
    - Asset Flexibility: On-demand image resizing, even for images stored on remote servers 
    

virtual dom how work ?
--------------------------------------------------------------------------------
    lightweight copy of the real DOM in memory
    
    When a React app is first rendered, React creates a Virtual DOM based on the component tree.
    React then compares the Virtual DOM with the real DOM to determine what changes need to be made.
    The result of this comparison is a set of changes (or "diffs"), which are then applied to the real DOM.

What is React js
--------------------------------------------------------------------------------
    React is a JavaScript library for building user interfaces. React is used to build single - page applications. React allows us to create reusable UI components.

How does React Work?
--------------------------------------------------------------------------------
    React creates a VIRTUAL DOM in memory.
    Instead of manipulating the browser's DOM directly, React creates a virtual DOM in memory, where it does all the necessary manipulating, before making the changes in the browser DOM.

ES6
--------------------------------------------------------------------------------
    Classes
    Arrow Functions
    Variables(let, const, var)
    Array Methods like .map()
    Destructuring
    Modules
    Ternary Operator
    Spread Operator

what is JSX?
--------------------------------------------------------------------------------
    JSX stands for JavaScript XML.JSX allows us to write HTML in React. JSX makes it easier to write and add HTML in React. expression is {}

React Components
--------------------------------------------------------------------------------
    Components are independent and reusable bits of code.They serve the same purpose as JavaScript functions, but work in isolation and return HTML.
    Components come in two types, Class components and Function components, in this tutorial we will concentrate on Function components.

Props
--------------------------------------------------------------------------------
    Props are arguments passed into React components. Props are passed to components via HTML attributes. props stands for properties.
    Props are also how you pass data from one component to another, as parameters.

    To do this without Context, we will need to pass the state as "props" through each nested component. This is called "prop drilling".

React Events
--------------------------------------------------------------------------------
    Just like HTML DOM events, React can perform actions based on user events. React has the same events as HTML: click, change, mouseover etc.
    React event handlers are written inside curly braces: onClick={shoot} instead of onClick="shoot()".

keys or React List
--------------------------------------------------------------------------------
    Keys allow React to keep track of elements. the key should be a unique ID assigned to each item. As a last resort, you can use the array index as a key.
    A key is a special attribute you should include when mapping over arrays to render data. Key prop helps React identify which items have changed, are added, or are removed.
    


framework vs library
--------------------------------------------------------------------------------
framework - flow already defined, in framework there are multiple library used
library - flow defined by us, in library we cannot use framework



What is the difference between Element and Component?
--------------------------------------------------------------------------------
    An Element is a plain object describing what you want to appear on the screen in terms of the DOM nodes or other components. Elements can contain other Elements in their props. Creating a React element is cheap. Once an element is created, it cannot be mutated.

    Whereas a component can be declared in several different ways. It can be a class with a render() method or it can be defined as a function. In either case, it takes props as an input, and returns a JSX tree as the output:





Controlled vs Uncontrolled Components in ReactJS
--------------------------------------------------------------------------------
    In React, Controlled components refer to the components where the state and behaviors are controlled by Parent components while Uncontrolled components are the ones having control of their own state and manage the behaviors on themselves.

    Uncontrolled Components are the components that are not controlled by the React state and are handled by the DOM (Document Object Model). So in order to access any value that has been entered we take the help of refs.
    


        
The asynchronous callback
--------------------------------------------------------------------------------
    The asynchronous callback is executed after the execution of the higher-order function.
    Simply saying, the asynchronous callbacks are non-blocking: the higher-order function completes its execution without waiting for the callback. The higher-order function makes sure to execute the callback later on a certain event.

    example
    1. console.log('setTimeout() starts');
        setTimeout(function later() {
            console.log('later() called');
        }, 2000);
        console.log('setTimeout() completed');

        // logs 'setTimeout() starts'
        // logs 'setTimeout() completed'
        // logs 'later() called' (after 2 seconds)



Asynchronous callback function vs asynchronous function
--------------------------------------------------------------------------------
    The special keyword async placed before the function definition creates an asynchornous function:
    setTimeout is Asynchronous callback function





1. What is ReactJS?
    ReactJS is a JavaScript library used to build reusable components for the view layer in MVC architecture. It is highly efficient and uses a virtual DOM to render components. It works on the client side and is written in JSX.

2. What is Next js?
    Next.js is a powerful and flexible React framework that enables developers to build server-rendered and statically generated web applications.



20. What is StrictMode in React ?
  The React StrictMode can be viewed as a helper component that allows developers to code efficiently and brings to their attention any suspicious code which might have been accidentally added to the application. The StrictMode can be applied to any section of the application, not necessarily to the entire application



11. What is axios and how to use it in React?
  Axios, which is a popular library is mainly used to send asynchronous HTTP requests to REST endpoints. This library is very useful to perform CRUD operations.


10. Explain CORS in React?
  In ReactJS, Cross-Origin Resource Sharing (CORS) refers to the method that allows you to make requests to the server deployed at a different domain. As a reference, if the frontend and backend are at two different domains, we need CORS there.


3. What is the difference between useref and createRef in React ?
  useRef
      It is a hook.	
      It uses the same ref throughout.	
      It returns a mutable ref object.	
      It is used in functional components.	

  createRef
      It is a function.
      It creates a new ref every time.
      It returns a read-only ref object.
      It is used in class components.



20. What are synthetic event in React?
      In order to work as a cross-browser application, React has created a wrapper same as the native browser in order to avoid creating multiple implementations for multiple methods for multiple browsers, creating common names for all events across browsers. Another benefit is that it increases the performance of the application as React reuses the event object. 
  
  

12. What is a react developer tool?
      React Developer Tools is a Chrome DevTools extension for the React JavaScript library. A very useful tool, if you are working on React.js applications. This extension adds React debugging tools to the Chrome Developer Tools. It helps you to inspect and edit the React component tree that builds the page, and for each component, one can check the props, the state, hooks, etc.


11. What is React Fragments?
      when we are trying to render more than one root element we have to put the entire content inside the â€˜divâ€™ tag which is not loved by many developers. So since React 16.2 version, Fragments were introduced, and we use them instead of the extraneous â€˜divâ€™ tag. The following syntax is used to create fragment in react.



8. What are hooks in React?
      In React, Hooks are functions that allow you to "hook into" React's state and lifecycle features from functional components. They were introduced in React 16.8 to make it easier to manage state, side effects, context, and other React features without needing to write class components. Hooks enable you to write more modular and reusable code in functional components.
  
  Before hooks, state and lifecycle methods could only be used in class components. Hooks eliminate this limitation, making functional components just as powerful and flexible as class components.


20. Explain one way data binding in React?
  ReactJS uses one-way data binding which can be Component to View or View to Component. It is also known as one-way data flow


8. How do browsers read JSX?
  In general, browsers are not capable of reading JSX and only have the capacity to read pure JavaScript. The web browsers read JSX with the help of a transpiler. Transpilers are used to convert JSX into JavaScript. The transpiler used is called Babel















